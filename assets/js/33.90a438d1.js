(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{301:function(t,n,a){"use strict";a.r(n);var s=a(14),e=Object(s.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"牛客竞赛-c语言基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#牛客竞赛-c语言基础"}},[t._v("#")]),t._v(" 牛客竞赛 C语言基础")]),t._v(" "),n("p",[t._v("%.3lf   输出时为四舍五入\n绝对值 abs()  # include"),n("cmath",[t._v("\nsqrt开根 sqrt()  是小数 #include"),n("cmath")],1)],1),t._v(" "),n("p",[t._v("ceil(x)函数返回大于等于x的最小double类型整数 例如:ceil(3.8) 返回 4.0\n这个是在求如3.5 是在3-4之间时用的。  对应的就是 floor（）"),n("br"),t._v("\n上下取整那道题可以看一下")]),t._v(" "),n("p",[t._v("数字反转之-三位数 这种还是用string 用at 吧   不然 120 -》012这个0不好龙")]),t._v(" "),n("h1",{attrs:{id:"奇怪"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#奇怪"}},[t._v("#")]),t._v(" 奇怪")]),t._v(" "),n("p",[t._v("妞妞学圆 用double不行用float可以\n我靠 这个double与float简直就是绝了，有时用double可以有时用float可以")]),t._v(" "),n("h2",{attrs:{id:"java"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#java"}},[t._v("#")]),t._v(" Java")]),t._v(" "),n("p",[t._v("Java语言严格区分大小写")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[t._v("    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n\t    \n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("  \n")])])]),n("p",[t._v("这是我们整个Java程序的入口点，我们称为主方法")]),t._v(" "),n("p",[t._v("变量与常量"),n("br"),t._v("\n变量"),n("br"),t._v("\n变量，指值可以变的量"),n("br"),t._v("\n要声明一个变量，我们需要使用以下格式：")]),t._v(" "),n("blockquote",[n("p",[t._v("[数据类型] [变量名称(标识符)];")])]),t._v(" "),n("p",[t._v("常量\n变量的值一直保持不变")]),t._v(" "),n("div",{staticClass:"language-java final int a = 666; //在变量前面添加final关键字，表示这是一个常量 extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[t._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//常量的值只有第一次赋值可以修改，其他任何情况下都不行：  ")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//比如我现在就是在 a=777，这是不行的  ")]),t._v("\n")])])]),n("p",[t._v("基本数据类型"),n("br"),t._v("\n整数类形")]),t._v(" "),n("ul",[n("li",[t._v("byte 字节型 （8个bit，也就是1个字节）范围：-128~+127")]),t._v(" "),n("li",[t._v("short 短整形（16个bit，也就是2个字节）范围：-32768~+32767")]),t._v(" "),n("li",[t._v("int 整形（32个bit，也就是4个字节）最常用的类型：-2147483648 ~ +2147483647")]),t._v(" "),n("li",[t._v("long 长整形（64个bit，也就是8个字节）范围：-9223372036854775808 ~ +9223372036854775807")])]),t._v(" "),n("p",[t._v("浮点类型")]),t._v(" "),n("ul",[n("li",[t._v("float 单精度浮点型 （32bit，4字节）")]),t._v(" "),n("li",[t._v("double 双精度浮点型（64bit，8字节）")])]),t._v(" "),n("p",[t._v("用国际标准 IEEE 754在计算机存放"),n("br"),t._v("\nlong类型的值居然可以直接丢给float类型隐式类型转换，很明显float只有32个bit位，而long有足足64个，这是什么情况？"),n("br"),t._v("\n怎么大的还可以隐式转换为小的？这是因为虽然float空间没有那么大，"),n("br"),t._v("\n但是由于是浮点类型，指数可以变化，最大的数值表示范围实际上是大于long类型的，虽然会丢失精度，但是确实可以表示这么大的数。")]),t._v(" "),n("p",[t._v("字符类型")]),t._v(" "),n("p",[t._v("char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535  ASCII码"),n("br"),t._v("\n这里的字符表里面不就128个字符吗，那char干嘛要两个字节的空间来存放呢？"),n("br"),t._v("\n我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），"),n("br"),t._v("\n用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。"),n("br"),t._v("\nISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode（准确的说应该是规定的字符集，包含了几乎全世界所有语言的字符），"),n("br"),t._v("\n规定每个字符必须使用两个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）"),n("br"),t._v("\n但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，肯定不能直接就这样去表示，这会导致某些字符浪费了很多空间，"),n("br"),t._v("\n我们需要一个更加好用的具体的字符编码方式。所以最后就有了UTF-8编码格式（它是Unicode字符集的一个编码规则）"),n("br"),t._v("\n所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式，随着更多的字符加入，实际上两个字节也装不下了，可能需要3个甚至4个字节才能表示某些符号，后来就有了UTF-16编码格式，"),n("br"),t._v("\nJava在运行时采用的就是UTF-16，几乎全世界的语言用到的字符都可以表示出来。"),n("br"),t._v("\nUnicode 是“字符集”，也就是有哪些字符，而UTF-8、UTF-16 是“编码规则”，也就是怎么对这些字符编码，怎么以二进制的形式保存，千万不要搞混了。")]),t._v(" "),n("p",[t._v("Java程序在编译为.class文件之后，会采用UTF-8的编码格式，支持的字符也非常多，所以你甚至可以直接把变量名写成中文，依然可以编译通过：")]),t._v(" "),n("p",[t._v("String类型，这种类型并不是基本数据类型，它是对象类型")]),t._v(" "),n("p",[t._v("布尔类型boolean"),n("br"),t._v("\n布尔类型是Java中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态："),n("br"),t._v("\ntrue - 真"),n("br"),t._v("\nfalse - 假"),n("br"),t._v("\n布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。")]),t._v(" "),n("p",[t._v("加减号作为正负符号使用 加法支持对字符串的拼接"),n("br"),t._v("\n两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）"),n("br"),t._v("\n整数和小数一起计算，由于所有的整数范围都比小数小，根据我们上一部分介绍的转换规则，整数和小数一起计算时"),n("br"),t._v("\n，所有的整数都会变成小数参与运算，所以说最后的结果也就是小数了")]),t._v(" "),n("p",[t._v("有两个整数需要进行计算，但是我们就是希望可以得到一个小数的结果 int a = 5;"),n("br"),t._v("\nint b = 6;"),n("br"),t._v("\ndouble c = (int)a"),n("br"),t._v("\nc/b.sout")]),t._v(" "),n("p",[t._v("a++"),n("br"),t._v("\n先赋值，再加1"),n("br"),t._v("\n--a"),n("br"),t._v("\n先自加，再赋值")]),t._v(" "),n("p",[t._v("同理 也有 a *= 2;  或者a /= 2;"),n("br"),t._v("\n位运算符"),n("br"),t._v("\n关系运算符  结果是一个boolean类型的值"),n("br"),t._v("\n逻辑运算符")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("        &&     与运算，要求两边同时为true才能返回true  \n        ||     或运算，要求两边至少要有一个为true才能返回true  \n        !      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转  \n")])])]),n("p",[t._v("流程控制"),n("br"),t._v("\nfor循环的三个表达式并不一定需要编写，我们甚至可以三个都不写："),n("br"),t._v("\n如果没有表达式2，那么整个for循环就没有结束条件，默认会判定为真，此时就会出现无限循环的情况（无限循环是很危险的，因为它会疯狂地消耗CPU资源来执行循环，可能很快你的CPU就满载了，一定要避免）"),n("br"),t._v("\n循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字："),n("br"),t._v("\ncontinue关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行continue进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。"),n("br"),t._v("\nbreak关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。")]),t._v(" "),n("p",[t._v("类名首字母大写")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("public static void main(String[] args) {  \n    Person p1 = new Person();    Person p2 = p1;}  \n")])])]),n("p",[t._v("我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，"),n("br"),t._v("\np2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在）")]),t._v(" "),n("p",[t._v("方法")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("返回值类型 方法名称() {  \n      方法体...  \n}  \n")])])]),n("p",[t._v("实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身"),n("br"),t._v("\n值传递"),n("br"),t._v("\n如果直接创建对象，那么对象的属性都会存在初始值"),n("br"),t._v("\n参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身  一般来说就是值交换顺序的情况"),n("br"),t._v("\n但是有对象的时候要注意 对象不是值是引用所以要注意")]),t._v(" "),n("p",[t._v("想要在方法中访问到当前对象的属性，那么可以使用this关键字，来明确表示当前类的示例对象本身")]),t._v(" "),n("p",[t._v("方法的重载"),n("br"),t._v("\n方法名字相同其他不同"),n("br"),t._v("\n包括我们之前一直在使用的println方法，其实也是重载了很多次的，因为要支持各种值的打印。"),n("br"),t._v("\n注意，如果仅仅是返回值的不同，是不支持重载的：")]),t._v(" "),n("p",[t._v("方法之间是可以相互调用的：")]),t._v(" "),n("p",[t._v("构造方法"),n("br"),t._v("\n我们接着来看一种比较特殊的方法，构造方法。"),n("br"),t._v("\n我们前面创建对象，都是直接使用new关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，"),n("br"),t._v("\n那么能否实现在对象创建时就为其指定名字、年龄、性别呢？要在对象创建时进行处理，我们可以使用构造方法（构造器）来完成。"),n("br"),t._v("\n实际上每个类都有一个默认的构造方法")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n    "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" name"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" age"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" sex"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  \n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//反编译中，多出来了这样一个方法，这其实就是构造方法  ")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("  \n")])])]),n("p",[t._v("构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改："),n("br"),t._v("\n构造方法会在new的时候自动执行："),n("br"),t._v("\n注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，"),n("br"),t._v("\n否则要创建这个类的对象，必须调用我们自己定义的构造方法：")]),t._v(" "),n("p",[t._v("静态变量和静态方法"),n("br"),t._v("\n静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。我们通过使用static关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。"),n("br"),t._v("\n静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。我们通过使用"),n("code",[t._v("static")]),t._v("关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。"),n("br"),t._v("\n静态的感觉就像是公共区")]),t._v(" "),n("p",[t._v("数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建）即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。 所以需要需要使用new 关键字")]),t._v(" "),n("p",[t._v("![[Pasted image 20230403100001.png]]")]),t._v(" "),n("p",[t._v("因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值：无法使用"),n("code",[t._v("this")]),t._v("关键字，因为this关键字代表的是当前的对象本身\n所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。")]),t._v(" "),n("p",[t._v("如果父类存在一个有参构造方法，子类必须在构造方法中调用：\n因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么我们就需要手动指定了：")]),t._v(" "),n("blockquote",[n("p",[t._v('public Student(String name, int age, String sex) { //因为学生职业已经确定，所以说学生直接填写就可以了\nsuper(name, age, sex, "学生"); //使用super代表父类，父类的构造方法就是super()\n}')])]),t._v(" "),n("p",[t._v("默认提供的"),n("code",[t._v("equals")]),t._v("\n因为默认比较的是两个对象是否为同一个对象")]),t._v(" "),n("p",[t._v("静态方法不支持重写，因为它是属于类本身的，但是它可以被继承\n基于这种方法可以重写的特性，对于一个类定义的行为，不同的子类可以出现不同的行为 如成绩的输出")]),t._v(" "),n("p",[t._v("我们如果不希望子类重写某个方法，我们可以在方法前添加"),n("code",[t._v("final")]),t._v("关键字，表示这个方法已经是最终形态：")]),t._v(" "),n("p",[t._v("如果父类中方法的可见性为"),n("code",[t._v("private")]),t._v("，那么子类同样无法访问，也就不能重写，但是可以定义同名方法，可以编译通过，但是并不是对父类方法的重写，仅仅是子类自己创建的一个新方法。\n重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用"),n("code",[t._v("super")]),t._v("关键字：")]),t._v(" "),n("blockquote",[n("p",[t._v('@Override\npublic void exam() {\nsuper.exam(); //调用父类的实现\nSystem.out.println("我是工人，做题我并不擅长，只能得到 D");\n}')])]),t._v(" "),n("p",[t._v("子类在重写父类方法时，不能降低父类方法中的可见性：")]),t._v(" "),n("p",[t._v("在我们学习了类的继承之后，实际上我们会发现，越是处于顶层定义的类，实际上可以进一步地进行抽象，比如我们前面编写的考试方法：\n这个方法再子类中一定会被重写，所以说除非子类中调用父类的实现，否则一般情况下永远都不会被调用，就像我们说一个人会不会考试一样，实际上人怎么考试是一个抽象的概念，而学生怎么考试和工人怎么考试，才是具体的一个实现，所以说，我们可以将人类进行进一步的抽象，让某些方法完全由子类来实现，父类中不需要提供实现。\n抽象类比类还要抽象\n而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法：\n抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类：\n抽象方法的访问权限不能为"),n("code",[t._v("private")]),t._v("：因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。")]),t._v(" "),n("blockquote",[n("p",[t._v("public abstract class Person { //通过添加abstract关键字，表示这个类是一个抽象类\nprotected String name; //大体内容其实普通类差不多\nprotected int age; protected String sex;\nprotected String profession;\nprotected Person(String name, int age, String sex, String profession) {\nthis.name = name;\nthis.age = age;\nthis.sex = sex;\nthis.profession = profession;\n}\npublic abstract void exam(); //抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体\n}\n接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！\npublic interface Study { //使用interface表示这是一个接口 void study(); //接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略 }")])]),t._v(" "),n("p",[t._v("接口不同于继承，接口可以同时实现多个：")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Student")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Study")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("A")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("B")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("C")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//多个接口的实现使用逗号隔开")]),t._v("\n  \n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。")]),t._v(" "),n("p",[t._v("接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Study")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//接口中定义的静态变量只能是public static final的 ")]),t._v("\n\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n\t\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//接口中定义的静态方法也只能是public的 ")]),t._v("\n\t\t"),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"我是静态方法"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\t"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("study")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("接口是可以继承自其他接口的：并且接口没有继承数量限制，接口支持多继承：")]),t._v(" "),n("p",[t._v("枚举类来完成 定死一些东西")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("enum")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Status")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//enum表示这是一个枚举类，枚举类的语法稍微有一些不一样")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token constant"}},[t._v("RUNNING")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[t._v("STUDY")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SLEEP")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("枚举类型的本质就是一个普通的类，但是它继承自"),n("code",[t._v("Enum")]),t._v("类，我们定义的每一个状态其实就是一个"),n("code",[t._v("public static final")]),t._v("的Status类型成员变量：")]),t._v(" "),n("p",[t._v("Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！\n所以才会有基本类型包装类\n![[Pasted image 20230403104150.png]]\n包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想）")]),t._v(" "),n("p",[t._v('包装类中提供了哪些其他的方法，\n1.包装类支持字符串直接转换\nInteger i = new Integer("666"); //直接将字符串的666，转换为数字666\n或者\nInteger i = new Integer("666"); //直接将字符串的666，转换为数字666\n2.对十六进制和八进制的字符串进行解码，得到对应的int值\nInteger i = Integer.decode("0xA6");\n3同理 可以将十进制的整数转换为其他进制的字符串\n超大数字的BigInteger\nBigDecimal可以实现小数的精确计算')]),t._v(" "),n("p",[t._v("创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的")]),t._v(" "),n("p",[t._v("数组本身也是一个对象，数组对象也是具有属性的\n.length  数组长度一开始就定死了 是"),n("code",[t._v("final")]),t._v("类型的，不允许进行修改\n数组既然是类型，那么肯定也是继承自Object类的 但是他除了clone 其他的好像都没有重写\n"),n("code",[t._v("foreach")]),t._v('语法来遍历\nfor (int i : array) { //int i就是每一个数组中的元素，array就是我们要遍历的数组\nSystem.out.print(i+" "); //每一轮循环，i都会更新成数组中下一个元素 }\n简洁了但只不过这仅仅是语法糖而已，编译之后依然是跟原来一样老老实实在遍历的：\n，对于基本类型的数组来说，是不支持自动装箱和拆箱的：\n由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的：')]),t._v(" "),n("p",[t._v("数组的延伸应用\n可变长参数  如public void test(String... strings)\n可变长参数本质就是一个数组")]),t._v(" "),n("p",[t._v("main(String[] args)的这个就是可变长数组  可以在运行时加参数")]),t._v(" "),n("p",[t._v('String类\nString本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象：\nString str = "Hello World!";   就是String str = new String("Hello World!");\n注意，如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象：')]),t._v(" "),n("blockquote",[n("p",[t._v('String str1 = "Hello World"; String str2 = "Hello World";\n就是一个对象')])]),t._v(" "),n("p",[t._v("但使用构造方法主动创建两个新的对象，那么就是不同的对象")]),t._v(" "),n("blockquote",[n("p",[t._v('String str1 = new String("Hello World");\nString str2 = new String("Hello World");')])]),t._v(" "),n("p",[t._v("所以想要判断两个字符串的内容是否相同，不要使用"),n("code",[t._v("==")]),t._v("，String类重载了"),n("code",[t._v("equals")]),t._v('方法用于判断和比较内容是否相同\nString也是一个类，那么肯定是具有一些方法的\n.length()这个长度是字符的数量\n因为双引号括起来的字符串本身就是一个实例对象，所以说我们也可以直接用\n"Hello World".length() 看起来好奇怪\n字符串的裁剪str.substring(0, 3)\n分割String[] strings = str.split(" "); 这里就是通过空格分隔\n字符数组和字符串之间是可以快速进行相互转换\nchar[] chars = str.toCharArray();\nString str = new String(chars);')]),t._v(" "),n("p",[t._v("当拼接太多时，每一次都会形成新的对象，所以要用")]),t._v(" "),n("blockquote",[n("p",[t._v('String str1 = "你看";\nString str2 = "这";\nString str3 = "汉堡";\nString str4 = "做滴";\nString str5 = "行不行";\nStringBuilder builder = new StringBuilder();\nbuilder.append(str1).append(str2).append(str3).append(str4).append(str5);\nSystem.out.println(builder.toString());')])]),t._v(" "),n("p",[t._v("StringBuilder的类型，就是专门用于构造字符串的\n弥补了字符串不能修改的不足\n裁剪\nbuilder.delete(2, 4); //删除2到4这个范围内的字符\n还有许多")]),t._v(" "),n("h3",{attrs:{id:"正则表达式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[t._v("#")]),t._v(" 正则表达式")]),t._v(" "),n("p",[t._v("字符串判断格式  如邮箱格式为 数字/字母@数字/字母.com\n正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("123")]),t._v(" "),n("th",[t._v("123")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("123")]),t._v(" "),n("td",[t._v("123")])])])]),t._v(" "),n("p",[t._v('手动抛出一个异常来终止程序继续运行下\n抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息\n异常的抛出同样需要创建一个异常对象\nthrow new RuntimeException("被除数不能为0"); //使用throw关键字来抛出异常\n当程序没有按照我们理想的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）')]),t._v(" "),n("p",[t._v("我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//使用try-catch语句进行异常捕获")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" object "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        object"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NullPointerException")]),t._v(" e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("   "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//因为异常本身也是一个对象，catch中实际上就是用一个局部变量去接收异常")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"程序继续正常运行！"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("这里我们捕获的是NullPointerException空指针异常：\n可以看到，当我们捕获异常之后，程序可以继续正常运行，并不会像之前一样直接结束掉。")])])}),[],!1,null,null,null);n.default=e.exports}}]);