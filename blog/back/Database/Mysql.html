<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Mysql | 邓一</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="欢迎来到我的博客">
    
    <link rel="preload" href="/assets/css/0.styles.e8e4f3a3.css" as="style"><link rel="preload" href="/assets/js/app.e5928079.js" as="script"><link rel="preload" href="/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/assets/js/9.8d3bb58f.js" as="script"><link rel="prefetch" href="/assets/js/10.0ba94a97.js"><link rel="prefetch" href="/assets/js/11.ef013dd7.js"><link rel="prefetch" href="/assets/js/12.e14bf2ae.js"><link rel="prefetch" href="/assets/js/13.dc4038ea.js"><link rel="prefetch" href="/assets/js/14.8423bf27.js"><link rel="prefetch" href="/assets/js/15.a6a4d30e.js"><link rel="prefetch" href="/assets/js/16.58c6364a.js"><link rel="prefetch" href="/assets/js/3.a72851b7.js"><link rel="prefetch" href="/assets/js/4.d12742be.js"><link rel="prefetch" href="/assets/js/5.216cae74.js"><link rel="prefetch" href="/assets/js/6.2d0a63f8.js"><link rel="prefetch" href="/assets/js/7.974f9de8.js"><link rel="prefetch" href="/assets/js/8.a286f573.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e8e4f3a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">邓一</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/front/html/" class="nav-link">
  html
</a></li><li class="dropdown-item"><!----> <a href="/blog/front/css/" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/blog/front/js/" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  百度
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/back/Database/" class="nav-link router-link-active">
  数据库
</a></li></ul></div></div><div class="nav-item"><a href="/about.html" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="https://blog.isww.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  邓一博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/front/html/" class="nav-link">
  html
</a></li><li class="dropdown-item"><!----> <a href="/blog/front/css/" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/blog/front/js/" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="https://www.baidu.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  百度
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow down"></span></button> <button type="button" aria-label="后端" class="mobile-dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/back/Database/" class="nav-link router-link-active">
  数据库
</a></li></ul></div></div><div class="nav-item"><a href="/about.html" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="https://blog.isww.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  邓一博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Mysql</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/back/Database/Mysql.html#数据库的创建" class="sidebar-link">数据库的创建</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/Database/Mysql.html#数据库的规范化" class="sidebar-link">数据库的规范化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#第一范式-1nf" class="sidebar-link">第一范式（1NF）</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#第二范式-2nf" class="sidebar-link">第二范式（2NF）</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#第三范式-3nf" class="sidebar-link">第三范式（3NF）</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#bcnf" class="sidebar-link">BCNF</a></li></ul></li><li><a href="/blog/back/Database/Mysql.html#认识sql语句" class="sidebar-link">认识SQL语句</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/Database/Mysql.html#数据库定义语言-ddl" class="sidebar-link">数据库定义语言（DDL）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#数据库操作" class="sidebar-link">数据库操作</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#创建表" class="sidebar-link">创建表</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#sql数据类型" class="sidebar-link">SQL数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#列级约束条件" class="sidebar-link">列级约束条件</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#表级约束条件" class="sidebar-link">表级约束条件</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#修改表" class="sidebar-link">修改表</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#删除表" class="sidebar-link">删除表</a></li></ul></li><li><a href="/blog/back/Database/Mysql.html#数据库操纵语言-dml" class="sidebar-link">数据库操纵语言（DML）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#插入数据" class="sidebar-link">插入数据</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#修改数据" class="sidebar-link">修改数据</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#删除数据" class="sidebar-link">删除数据</a></li></ul></li><li><a href="/blog/back/Database/Mysql.html#数据库查询语言-dql" class="sidebar-link">数据库查询语言（DQL）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#单表查询" class="sidebar-link">单表查询</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#常用查询条件" class="sidebar-link">常用查询条件</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#排序查询" class="sidebar-link">排序查询</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#聚集函数" class="sidebar-link">聚集函数</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#分组和分页查询" class="sidebar-link">分组和分页查询</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#多表查询" class="sidebar-link">多表查询</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#自身连接查询" class="sidebar-link">自身连接查询</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#外连接查询" class="sidebar-link">外连接查询</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#嵌套查询" class="sidebar-link">嵌套查询</a></li></ul></li><li><a href="/blog/back/Database/Mysql.html#数据库控制语言-dcl" class="sidebar-link">数据库控制语言（DCL）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#创建用户" class="sidebar-link">创建用户</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#登陆用户" class="sidebar-link">登陆用户</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#用户授权" class="sidebar-link">用户授权</a></li></ul></li><li><a href="/blog/back/Database/Mysql.html#视图" class="sidebar-link">视图</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/Database/Mysql.html#索引" class="sidebar-link">索引</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/Database/Mysql.html#触发器" class="sidebar-link">触发器</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/Database/Mysql.html#事务" class="sidebar-link">事务</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/Database/Mysql.html#函数" class="sidebar-link">函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#系统函数" class="sidebar-link">系统函数</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#自定义函数" class="sidebar-link">自定义函数</a></li></ul></li><li><a href="/blog/back/Database/Mysql.html#存储过程" class="sidebar-link">存储过程</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/Database/Mysql.html#存储引擎" class="sidebar-link">存储引擎</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/back/Database/Mysql.html#索引-2" class="sidebar-link">索引</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#单列索引" class="sidebar-link">单列索引</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#组合索引" class="sidebar-link">组合索引</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#索引底层原理" class="sidebar-link">索引底层原理</a></li></ul></li><li><a href="/blog/back/Database/Mysql.html#锁机制" class="sidebar-link">锁机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#读锁和写锁" class="sidebar-link">读锁和写锁</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#全局锁、表锁和行锁" class="sidebar-link">全局锁、表锁和行锁</a></li><li class="sidebar-sub-header"><a href="/blog/back/Database/Mysql.html#记录锁、间隙锁和临键锁" class="sidebar-link">记录锁、间隙锁和临键锁</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql"><a href="#mysql" class="header-anchor">#</a> Mysql</h1> <h3 id="数据模型"><a href="#数据模型" class="header-anchor">#</a> 数据模型</h3> <p>数据模型与现实世界中的模型一样，是对现实世界数据特征的一种抽象。实际上，我们之前学习的类就是对现实世界数据的一种抽象，比如一个学生的特征包括姓名，年龄，年级，学号，专业等，这些特征也称为实体的一种属性，属性具有以下特点：</p> <ul><li>属性不可再分</li> <li>一个实体的属性可以有很多个</li> <li>用于唯一区分不同实体的的属性，称为Key，比如每个同学的学号都是不一样的</li> <li>属性取值可以有一定的约束，比如性别只能是男或是女</li></ul> <p>实体或是属性之间可以具有一定的联系，比如一个老师可以教很多个学生，而学生相对于老师就是被教授的关系；又比如每个同学都有一个学号与其唯一对应，因此学号和学生之间也有一种联系。而像一个老师教多个学生的联系就是一种一对多的联系（1:n），而学号唯一对应，就是一种一对一的联系（1:1）；每一个老师不仅可以教多个学生，每一个学生也可以有多个教师，这就是一种多对多的联系（n:m）</p> <p>MySQL就是一种关系型数据库，通过使用关系型数据库，我们就可以很好地存储这样带有一定联系的数据。</p> <p><img src="http://notepicture.fvcsavstudy.cn/BackEnd/Database/mysql-1.jpg" alt="img"></p> <p>通过构建一个ER图，我们就能很好地理清不同数据模型之间的关系和特点。</p> <h2 id="数据库的创建"><a href="#数据库的创建" class="header-anchor">#</a> 数据库的创建</h2> <p>既然了解了属性和联系，那么我们就来尝试创建一个数据库，并在数据库中添加用于存放数据的表，每一张表都代表一种实体的数据。首先我们要明确，我们需要创建什么样子的表：</p> <ul><li>学生表：用于存放所有学生的数据，学生（<u>学号</u>，姓名，性别）</li> <li>教师表：用于存放所有教师的数据，教师（<u>教师号</u>，姓名）</li> <li>授课表：用于存放教师与学生的授课信息，授课（学号，教师号）</li></ul> <p>其中，标注下划线的属性，作为Key，用于区别于其他实体数据的唯一标记。</p> <p>为了理解起来更加轻松，我们从图形界面操作再讲到SQL语句，请不要着急。我们现在通过Navicat或idea自带的数据库客户端来创建一个数据库和上述三个表。</p> <h2 id="数据库的规范化"><a href="#数据库的规范化" class="header-anchor">#</a> 数据库的规范化</h2> <p>要去设计存放一个实体的表，我们就需要了解数据库的关系规范化，尽可能减少“不好”的关系存在，如何设计一个优良的关系模型是最关键的内容！简而言之，我们要学习一下每一个表该如何去设计。</p> <h3 id="第一范式-1nf"><a href="#第一范式-1nf" class="header-anchor">#</a> 第一范式（1NF）</h3> <p>第一范式是指数据库的每一列都是不可分割的基本数据项，而下面这样的就存在可分割的情况：</p> <ul><li>学生（姓名，电话号码）</li></ul> <p>电话号码实际上包括了<code>家用座机电话</code>和<code>移动电话</code>，因此它可以被拆分为：</p> <ul><li>学生（姓名，座机号码，手机号码）</li></ul> <p>满足第一范式是关系型数据库最基本的要求！</p> <h3 id="第二范式-2nf"><a href="#第二范式-2nf" class="header-anchor">#</a> 第二范式（2NF）</h3> <p>第二范式要求表中必须存在主键，且其他的属性必须完全依赖于主键，比如：</p> <ul><li>学生（<u>学号</u>，姓名，性别）</li></ul> <p>学号是每个学生的唯一标识，每个学生都有着不同的学号，因此此表中存在一个主键，并且每个学生的所有属性都依赖于学号，学号发生改变就代表学生发生改变，姓名和性别都会因此发生改变，所有此表满足第二范式。</p> <h3 id="第三范式-3nf"><a href="#第三范式-3nf" class="header-anchor">#</a> 第三范式（3NF）</h3> <p>在满足第二范式的情况下，所有的属性都不传递依赖于主键，满足第三范式。</p> <ul><li>学生借书情况（<u>借阅编号</u>，学生学号，书籍编号，书籍名称，书籍作者）</li></ul> <p>实际上书籍编号依赖于借阅编号，而书籍名称和书籍作者依赖于书籍编号，因此存在传递依赖的情况，我们可以将书籍信息进行单独拆分为另一张表：</p> <ul><li>学生借书情况（<u>借阅编号</u>，学生学号，书籍编号）</li> <li>书籍（<u>书籍编号</u>，书籍名称，书籍作者）</li></ul> <p>这样就消除了传递依赖，从而满足第三范式。</p> <h3 id="bcnf"><a href="#bcnf" class="header-anchor">#</a> BCNF</h3> <p>BCNF作为第三范式的补充，假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：</p> <p>(仓库ID, 存储物品ID) →(管理员ID, 数量)</p> <p>(管理员ID, 存储物品ID) → (仓库ID, 数量)</p> <p>所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p> <p>(仓库ID) → (管理员ID)</p> <p>(管理员ID) → (仓库ID)</p> <p>即存在关键字段决定关键字段的情况，如果修改管理员ID，那么就必须逐一进行修改，所以其不符合BCNF范式。</p> <hr> <h2 id="认识sql语句"><a href="#认识sql语句" class="header-anchor">#</a> 认识SQL语句</h2> <p>结构化查询语言（Structured Query Language）简称SQL，这是一种特殊的语言，它专门用于数据库的操作。每一种数据库都支持SQL，但是他们之间会存在一些细微的差异，因此不同的数据库都存在自己的“方言”。</p> <p>SQL语句不区分大小写（关键字推荐使用大写），它支持多行，并且需要使用<code>;</code>进行结尾！</p> <p>SQL也支持注释，通过使用<code>--</code>或是<code>#</code>来编写注释内容，也可以使用<code>/*</code>来进行多行注释。</p> <p>我们要学习的就是以下四种类型的SQL语言：</p> <ul><li>数据查询语言（Data Query Language, DQL）基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块。</li> <li>数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以INSERT、UPDATE、DELETE三种指令为核心，分别代表插入、更新与删除，是开发以数据为中心的应用程序必定会使用到的指令。</li> <li>数据库定义语言DDL(Data Definition Language)，是用于描述数据库中要存储的现实世界实体的语言。</li> <li>DCL（Data Control Language）是数据库控制语言。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL。</li></ul> <p>我们平时所说的CRUD其实就是增删改查（Create/Retrieve/Update/Delete）</p> <hr> <h2 id="数据库定义语言-ddl"><a href="#数据库定义语言-ddl" class="header-anchor">#</a> 数据库定义语言（DDL）</h2> <h3 id="数据库操作"><a href="#数据库操作" class="header-anchor">#</a> 数据库操作</h3> <p>我们可以通过<code>create database</code>来创建一个数据库：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">database</span> 数据库名
</code></pre></div><p>为了能够支持中文，我们在创建时可以设定编码格式：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> 数据库名 <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span> utf8 <span class="token keyword">COLLATE</span> utf8_general_ci<span class="token punctuation">;</span>
</code></pre></div><ul><li><strong>DEFAULT CHARACTER SET utf8</strong>：数据库字符集。设置数据库的默认编码为utf8，这里utf8中间不要&quot;-&quot;；</li> <li><strong>COLLATE utf8_general_ci:</strong>  数据库校对规则。该三部分分别为数据库字符集、通用、区分大小写。</li></ul> <p>如果我们创建错误了，我们可以将此数据库删除，通过使用<code>drop database</code>来删除一个数据库：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">database</span> 数据库名
</code></pre></div><h3 id="创建表"><a href="#创建表" class="header-anchor">#</a> 创建表</h3> <p>数据库创建完成后，我们一般通过<code>create table</code>语句来创建一张表：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> 表名<span class="token punctuation">(</span>列名 数据类型<span class="token punctuation">[</span>列级约束条件<span class="token punctuation">]</span><span class="token punctuation">,</span>
             列名 数据类型<span class="token punctuation">[</span>列级约束条件<span class="token punctuation">]</span><span class="token punctuation">,</span>
             <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
             <span class="token punctuation">[</span><span class="token punctuation">,</span>表级约束条件<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>列级约束</strong>有六种：</p> <ul><li>主键Primary key</li> <li>外键foreign key</li> <li>唯一 unique</li> <li>检查 checck</li> <li>默认default</li> <li>非空/空值 not null/ null</li></ul> <h3 id="sql数据类型"><a href="#sql数据类型" class="header-anchor">#</a> SQL数据类型</h3> <p>以下的数据类型用于字符串存储：</p> <ul><li>char(n)可以存储任意字符串，但是是固定长度为n，如果插入的长度小于定义长度时，则用空格填充。</li> <li>varchar(n)也可以存储任意数量字符串，长度不固定，但不能超过n，不会用空格填充。</li></ul> <p>以下数据类型用于存储数字：</p> <ul><li>smallint用于存储小的整数，范围在 (-32768，32767)</li> <li>int用于存储一般的整数，范围在 (-2147483648，2147483647)</li> <li>bigint用于存储大型整数，范围在 (-9,223,372,036,854,775,808，9,223,372,036,854,775,807)</li> <li>float用于存储单精度小数</li> <li>double用于存储双精度的小数</li></ul> <p>以下数据类型用于存储时间：</p> <ul><li>date存储日期</li> <li>time存储时间</li> <li>year存储年份</li> <li>datetime用于混合存储日期+时间</li></ul> <h3 id="列级约束条件"><a href="#列级约束条件" class="header-anchor">#</a> 列级约束条件</h3> <p>列级约束有六种：主键Primary key、外键foreign key 、唯一 unique、检查 check （MySQL不支持）、默认default 、非空/空值 not null/ null</p> <h3 id="表级约束条件"><a href="#表级约束条件" class="header-anchor">#</a> 表级约束条件</h3> <p>表级约束有四种：主键、外键、唯一、检查</p> <p>现在我们通过SQL语句来创建我们之前提到的三张表。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token punctuation">[</span><span class="token keyword">CONSTRAINT</span> <span class="token operator">&lt;</span>外键名<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> 字段名 <span class="token punctuation">[</span>，字段名<span class="token number">2</span>，…<span class="token punctuation">]</span> <span class="token keyword">REFERENCES</span> <span class="token operator">&lt;</span>主表名<span class="token operator">&gt;</span> 主键列<span class="token number">1</span> <span class="token punctuation">[</span>，主键列<span class="token number">2</span>，…<span class="token punctuation">]</span>
</code></pre></div><p>主键：表中经常有一个列或多列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键。当创建或更改表时可通过定义 PRIMARY KEY 约束来创建主键。一个表只能有一个 PRIMARY KEY 约束，而且 PRIMARY KEY 约束中的列不能接受<a href="https://baike.baidu.com/item/%E7%A9%BA%E5%80%BC/6506427?fromModule=lemma_inlink" target="_blank" rel="noopener noreferrer">空值<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。由于 PRIMARY KEY 约束确保唯一数据。</p> <h3 id="修改表"><a href="#修改表" class="header-anchor">#</a> 修改表</h3> <p>如果我们想修改表结构，我们可以通过<code>alter table</code>来进行修改：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">[</span><span class="token keyword">ADD</span> 新列名 数据类型<span class="token punctuation">[</span>列级约束条件<span class="token punctuation">]</span><span class="token punctuation">]</span>
							 <span class="token punctuation">[</span><span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> 列名<span class="token punctuation">[</span><span class="token keyword">restrict</span><span class="token operator">|</span><span class="token keyword">cascade</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
							 <span class="token punctuation">[</span><span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> 列名 新数据类型<span class="token punctuation">]</span>
</code></pre></div><p>我们可以通过ADD来添加一个新的列，通过DROP来删除一个列，不过我们可以添加restrict或cascade，默认是restrict，表示如果此列作为其他表的约束或视图引用到此列时，将无法删除，而cascade会强制连带引用此列的约束、视图一起删除。还可以通过ALTER来修改此列的属性。</p> <h3 id="删除表"><a href="#删除表" class="header-anchor">#</a> 删除表</h3> <p>我们可以通过<code>drop table</code>来删除一个表：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">[</span><span class="token keyword">restrict</span><span class="token operator">|</span><span class="token keyword">cascade</span><span class="token punctuation">]</span>
</code></pre></div><p>其中restrict和cascade上面的效果一致。</p> <hr> <h2 id="数据库操纵语言-dml"><a href="#数据库操纵语言-dml" class="header-anchor">#</a> 数据库操纵语言（DML）</h2> <p>前面我们已经学习了如何使用SQL语句来创建、修改、删除数据库以及表，而如何向数据库中插入、删除、更新数据，将是本版块讨论的重点。</p> <h3 id="插入数据"><a href="#插入数据" class="header-anchor">#</a> 插入数据</h3> <p>通过使用<code>insert into</code>语句来向数据库中插入一条数据（一条记录）：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token keyword">VALUES</span><span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">,</span> 值<span class="token number">3</span><span class="token punctuation">)</span>
</code></pre></div><p>如果插入的数据与列一一对应，那么可以省略列名，但是如果希望向指定列上插入数据，就需要给出列名：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名<span class="token punctuation">(</span>列名<span class="token number">1</span><span class="token punctuation">,</span> 列名<span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><p>我们也可以一次性向数据库中插入多条数据：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名<span class="token punctuation">(</span>列名<span class="token number">1</span><span class="token punctuation">,</span> 列名<span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>值<span class="token number">1</span><span class="token punctuation">,</span> 值<span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><p>我们来试试看向我们刚刚创建的表中添加三条数据。</p> <h3 id="修改数据"><a href="#修改数据" class="header-anchor">#</a> 修改数据</h3> <p>我们可以通过<code>update</code>语句来更新表中的数据：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> 表名 <span class="token keyword">SET</span> 列名<span class="token operator">=</span>值<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">WHERE</span> 条件
</code></pre></div><p>注意，SQL语句中的等于判断是<code>=</code></p> <p><strong>警告</strong>：如果忘记添加<code>WHERE</code>字句来限定条件，将使得整个表中此列的所有数据都被修改！</p> <h3 id="删除数据"><a href="#删除数据" class="header-anchor">#</a> 删除数据</h3> <p>我们可以通过使用<code>delete</code>来删除表中的数据：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 表名
</code></pre></div><p>通过这种方式，将删除表中全部数据，我们也可以使用<code>where</code>来添加条件，只删除指定的数据：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件
</code></pre></div><hr> <h2 id="数据库查询语言-dql"><a href="#数据库查询语言-dql" class="header-anchor">#</a> 数据库查询语言（DQL）</h2> <p>数据库的查询是我们整个数据库学习中的重点内容，面对数据库中庞大的数据，该如何去寻找我们想要的数据，就是我们主要讨论的问题。</p> <h3 id="单表查询"><a href="#单表查询" class="header-anchor">#</a> 单表查询</h3> <p>单表查询是最简单的一种查询，我们只需要在一张表中去查找数据即可，通过使用<code>select</code>语句来进行单表查询：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 指定查询某一列数据</span>
<span class="token keyword">SELECT</span> 列名<span class="token punctuation">[</span><span class="token punctuation">,</span>列名<span class="token punctuation">]</span> <span class="token keyword">FROM</span> 表名
<span class="token comment">-- 会以别名显示此列</span>
<span class="token keyword">SELECT</span> 列名 别名 <span class="token keyword">FROM</span> 表名
<span class="token comment">-- 查询所有的列数据</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名
<span class="token comment">-- 只查询不重复的值</span>
<span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> 列名 <span class="token keyword">FROM</span> 表名
</code></pre></div><p>我们也可以添加<code>where</code>字句来限定查询目标：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件
</code></pre></div><h3 id="常用查询条件"><a href="#常用查询条件" class="header-anchor">#</a> 常用查询条件</h3> <ul><li>一般的比较运算符，包括=、&gt;、&lt;、&gt;=、&lt;=、!=等。</li> <li>是否在集合中：in、not in</li> <li>字符模糊匹配：like，not like</li> <li>多重条件连接查询：and、or、not</li></ul> <p>我们来尝试使用一下上面这几种条件。</p> <h3 id="排序查询"><a href="#排序查询" class="header-anchor">#</a> 排序查询</h3> <p>我们可以通过<code>order by</code>来将查询结果进行排序：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 列名 <span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span>
</code></pre></div><p>使用ASC表示升序排序，使用DESC表示降序排序，默认为升序。</p> <p>我们也可以可以同时添加多个排序：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件 <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> 列名<span class="token number">1</span> <span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">,</span> 列名<span class="token number">2</span> <span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span>
</code></pre></div><p>这样会先按照列名1进行排序，每组列名1相同的数据再按照列名2排序。</p> <h3 id="聚集函数"><a href="#聚集函数" class="header-anchor">#</a> 聚集函数</h3> <p>聚集函数一般用作统计，包括：</p> <ul><li><code>count([distinct]*)</code>统计所有的行数（distinct表示去重再统计，下同）</li> <li><code>count([distinct]列名)</code>统计某列的值总和</li> <li><code>sum([distinct]列名)</code>求一列的和（注意必须是数字类型的）</li> <li><code>avg([distinct]列名)</code>求一列的平均值（注意必须是数字类型）</li> <li><code>max([distinct]列名)</code>求一列的最大值</li> <li><code>min([distinct]列名)</code>求一列的最小值</li></ul> <p>一般聚集函数是这样使用的：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> 列名<span class="token punctuation">)</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件 
</code></pre></div><h3 id="分组和分页查询"><a href="#分组和分页查询" class="header-anchor">#</a> 分组和分页查询</h3> <p>通过使用<code>group by</code>来对查询结果进行分组，它需要结合聚合函数一起使用：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件 <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> 列名
</code></pre></div><p>我们还可以添加<code>having</code>来限制分组条件：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件 <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> 列名 <span class="token keyword">HAVING</span> 约束条件
</code></pre></div><p>我们可以通过<code>limit</code>来限制查询的数量，只取前n个结果：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">LIMIT</span> 数量
</code></pre></div><p>我们也可以进行分页：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">LIMIT</span> 起始位置<span class="token punctuation">,</span>数量
</code></pre></div><h3 id="多表查询"><a href="#多表查询" class="header-anchor">#</a> 多表查询</h3> <p>多表查询是同时查询的两个或两个以上的表，多表查询会提通过连接转换为单表查询。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表<span class="token number">1</span><span class="token punctuation">,</span> 表<span class="token number">2</span>
</code></pre></div><p>直接这样查询会得到两张表的笛卡尔积，也就是每一项数据和另一张表的每一项数据都结合一次，会产生庞大的数据。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表<span class="token number">1</span><span class="token punctuation">,</span> 表<span class="token number">2</span> <span class="token keyword">WHERE</span> 条件
</code></pre></div><p>这样，只会从笛卡尔积的结果中得到满足条件的数据。</p> <p>**注意：**如果两个表中都带有此属性吗，需要添加表名前缀来指明是哪一个表的数据。</p> <h3 id="自身连接查询"><a href="#自身连接查询" class="header-anchor">#</a> 自身连接查询</h3> <p>自身连接，就是将表本身和表进行笛卡尔积计算，得到结果，但是由于表名相同，因此要先起一个别名：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名 别名<span class="token number">1</span><span class="token punctuation">,</span> 表名 别名<span class="token number">2</span>
</code></pre></div><p>其实自身连接查询和前面的是一样的，只是连接对象变成自己和自己了。</p> <h3 id="外连接查询"><a href="#外连接查询" class="header-anchor">#</a> 外连接查询</h3> <p>外连接就是专门用于联合查询情景的，比如现在有一个存储所有用户的表，还有一张用户详细信息的表，我希望将这两张表结合到一起来查看完整的数据，我们就可以通过使用外连接来进行查询，外连接有三种方式：</p> <ul><li>通过使用<code>inner join</code>进行内连接，只会返回两个表满足条件的交集部分：</li></ul> <p><img src="http://notepicture.fvcsavstudy.cn/BackEnd/Database/mysql-2.png" alt="在这里插入图片描述"></p> <ul><li>通过使用<code>left join</code>进行左连接，不仅会返回两个表满足条件的交集部分，也会返回左边表中的全部数据，而在右表中缺失的数据会使用<code>null</code>来代替（右连接<code>right join</code>同理，只是反过来而已，这里就不再介绍了）：</li></ul> <p><img src="http://notepicture.fvcsavstudy.cn/BackEnd/Database/mysql-3.png" alt="在这里插入图片描述"></p> <h3 id="嵌套查询"><a href="#嵌套查询" class="header-anchor">#</a> 嵌套查询</h3> <p>我们可以将查询的结果作为另一个查询的条件，比如：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 列名 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> 列名 <span class="token keyword">FROM</span> 表名 <span class="token keyword">WHERE</span> 条件<span class="token punctuation">)</span>
</code></pre></div><p>我们来再次尝试编写一下在最开始我们查找某教师所有学生的SQL语句。</p> <hr> <h2 id="数据库控制语言-dcl"><a href="#数据库控制语言-dcl" class="header-anchor">#</a> 数据库控制语言（DCL）</h2> <p>庞大的数据库不可能由一个人来管理，我们需要更多的用户来一起管理整个数据库。</p> <h3 id="创建用户"><a href="#创建用户" class="header-anchor">#</a> 创建用户</h3> <p>我们可以通过<code>create user</code>来创建用户：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> 用户名 identified <span class="token keyword">by</span> 密码<span class="token punctuation">;</span>
</code></pre></div><p>也可以不带密码：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> 用户名<span class="token punctuation">;</span>
</code></pre></div><p>我们可以通过@来限制用户登录的登录IP地址，<code>%</code>表示匹配所有的IP地址，默认使用的就是任意IP地址。</p> <h3 id="登陆用户"><a href="#登陆用户" class="header-anchor">#</a> 登陆用户</h3> <p>首先需要添加一个环境变量，然后我们通过cmd去登陆mysql：</p> <div class="language-sql extra-class"><pre class="language-sql"><code>login <span class="token operator">-</span>u 用户名 <span class="token operator">-</span>p
</code></pre></div><p>输入密码后即可登陆此用户，我们输入以下命令来看看能否访问所有数据库：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token keyword">databases</span><span class="token punctuation">;</span>
</code></pre></div><p>我们发现，虽然此用户能够成功登录，但是并不能查看完整的数据库列表，这是因为此用户还没有权限！</p> <h3 id="用户授权"><a href="#用户授权" class="header-anchor">#</a> 用户授权</h3> <p>我们可以通过使用<code>grant</code>来为一个数据库用户进行授权：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">grant</span> <span class="token keyword">all</span><span class="token operator">|</span>权限<span class="token number">1</span><span class="token punctuation">,</span>权限<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>列<span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">on</span> 数据库<span class="token punctuation">.</span>表 <span class="token keyword">to</span> 用户 <span class="token punctuation">[</span><span class="token keyword">with</span> <span class="token keyword">grant</span> <span class="token keyword">option</span><span class="token punctuation">]</span>
</code></pre></div><p>其中all代表授予所有权限，当数据库和表为<code>*</code>，代表为所有的数据库和表都授权。如果在最后添加了<code>with grant option</code>，那么被授权的用户还能将已获得的授权继续授权给其他用户。</p> <p>我们可以使用<code>revoke</code>来收回一个权限：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">revoke</span> <span class="token keyword">all</span><span class="token operator">|</span>权限<span class="token number">1</span><span class="token punctuation">,</span>权限<span class="token number">2.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>列<span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token keyword">on</span> 数据库<span class="token punctuation">.</span>表 <span class="token keyword">from</span> 用户
</code></pre></div><hr> <h2 id="视图"><a href="#视图" class="header-anchor">#</a> 视图</h2> <p>视图本质就是一个查询的结果，不过我们每次都可以通过打开视图来按照我们想要的样子查看数据。既然视图本质就是一个查询的结果，那么它本身就是一个虚表，并不是真实存在的，数据实际上还是存放在原来的表中。</p> <p>我们可以通过<code>create view</code>来创建视图;</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> 视图名称<span class="token punctuation">(</span>列名<span class="token punctuation">)</span> <span class="token keyword">as</span> 子查询语句 <span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token keyword">CHECK</span> <span class="token keyword">OPTION</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>WITH CHECK OPTION是指当创建后，如果更新视图中的数据，是否要满足子查询中的条件表达式，不满足将无法插入，创建后，我们就可以使用<code>select</code>语句来直接查询视图上的数据了，因此，还能在视图的基础上，导出其他的视图。</p> <ol><li>若视图是由两个以上基本表导出的，则此视图不允许更新。</li> <li>若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT和UPDATE操作，但允许执行DELETE操作。</li> <li>若视图的字段来自集函数，则此视图不允许更新。</li> <li>若视图定义中含有GROUP BY子句，则此视图不允许更新。</li> <li>若视图定义中含有DISTINCT短语，则此视图不允许更新。</li> <li>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新。例如将成绩在平均成绩之上的元组定义成一个视图GOOD_SC： CREATE VIEW GOOD_SC AS SELECT Sno, Cno, Grade FROM SC WHERE Grade &gt; (SELECT AVG(Grade) FROM SC); 　　导出视图GOOD_SC的基本表是SC，内层查询中涉及的表也是SC，所以视图GOOD_SC是不允许更新的。</li> <li>一个不允许更新的视图上定义的视图也不允许更新</li></ol> <p>通过<code>drop</code>来删除一个视图：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">view</span> apptest
</code></pre></div><hr> <h2 id="索引"><a href="#索引" class="header-anchor">#</a> 索引</h2> <p>在数据量变得非常庞大时，通过创建索引，能够大大提高我们的查询效率，就像Hash表一样，它能够快速地定位元素存放的位置，我们可以通过下面的命令创建索引：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 创建索引</span>
<span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> 索引名称 <span class="token keyword">ON</span> 表名 <span class="token punctuation">(</span>列名<span class="token punctuation">)</span>
<span class="token comment">-- 查看表中的索引</span>
<span class="token keyword">show</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> student
</code></pre></div><p>我们也可以通过下面的命令删除一个索引：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">drop</span> <span class="token keyword">index</span> 索引名称 <span class="token keyword">on</span> 表名
</code></pre></div><p>虽然添加索引后会使得查询效率更高，但是我们不能过度使用索引，索引为我们带来高速查询效率的同时，也会在数据更新时产生额外建立索引的开销，同时也会占用磁盘资源。</p> <hr> <h2 id="触发器"><a href="#触发器" class="header-anchor">#</a> 触发器</h2> <p>触发器就像其名字一样，在某种条件下会自动触发，在<code>select</code>/<code>update</code>/<code>delete</code>时，会自动执行我们预先设定的内容，触发器通常用于检查内容的安全性，相比直接添加约束，触发器显得更加灵活。</p> <p>触发器所依附的表称为基本表，当触发器表上发生<code>select</code>/<code>update</code>/<code>delete</code>等操作时，会自动生成两个临时的表（new表和old表，只能由触发器使用）</p> <p>比如在<code>insert</code>操作时，新的内容会被插入到new表中；在<code>delete</code>操作时，旧的内容会被移到old表中，我们仍可在old表中拿到被删除的数据；在<code>update</code>操作时，旧的内容会被移到old表中，新的内容会出现在new表中。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TRIGGER</span> 触发器名称 <span class="token punctuation">[</span>BEFORE<span class="token operator">|</span><span class="token keyword">AFTER</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">INSERT</span><span class="token operator">|</span><span class="token keyword">UPDATE</span><span class="token operator">|</span><span class="token keyword">DELETE</span><span class="token punctuation">]</span> <span class="token keyword">ON</span> 表名<span class="token operator">/</span>视图名 <span class="token keyword">FOR EACH ROW</span> <span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> student<span class="token punctuation">.</span>sno <span class="token operator">=</span> new<span class="token punctuation">.</span>sno
</code></pre></div><p>FOR EACH ROW表示针对每一行都会生效，无论哪行进行指定操作都会执行触发器！</p> <p>通过下面的命令来查看触发器：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SHOW</span> TRIGGERS
</code></pre></div><p>如果不需要，我们就可以删除此触发器：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> 触发器名称
</code></pre></div><hr> <h2 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h2> <p>当我们要进行的操作非常多时，比如要依次删除很多个表的数据，我们就需要执行大量的SQL语句来完成，这些数据库操作语句就可以构成一个事务！只有Innodb引擎支持事务，我们可以这样来查看支持的引擎：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SHOW</span> ENGINES<span class="token punctuation">;</span>
</code></pre></div><p>MySQL默认采用的是Innodb引擎，我们也可以去修改为其他的引擎。</p> <p>事务具有以下特性：</p> <ul><li><strong>原子性</strong>：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li> <li><strong>一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li> <li><strong>隔离性</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li> <li><strong>持久性</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul> <p>我们通过以下例子来探究以下事务：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">begin</span><span class="token punctuation">;</span>   <span class="token comment">#开始事务</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">rollback</span><span class="token punctuation">;</span>  <span class="token comment">#回滚事务</span>
<span class="token keyword">savepoint</span> 回滚点<span class="token punctuation">;</span>  <span class="token comment">#添加回滚点</span>
<span class="token keyword">rollback</span> <span class="token keyword">to</span> 回滚点<span class="token punctuation">;</span> <span class="token comment">#回滚到指定回滚点</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span> <span class="token comment">#提交事务</span>
<span class="token comment">-- 一旦提交，就无法再进行回滚了！</span>
</code></pre></div><hr> <h1 id="mysql高级"><a href="#mysql高级" class="header-anchor">#</a> MySQL高级</h1> <p>在JavaWeb阶段，我们初步认识了MySQL数据库，包括一些基本操作，比如创建数据库、表、触发器，以及最基本的增删改查、事务等操作。而在此阶段，我们将继续深入学习MySQL，了解它的更多高级玩法，也相当于进行复习。</p> <h2 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h2> <p>其实函数我们在之前已经接触到一部分了，在JavaWeb阶段，我们了解了聚集函数，聚集函数一般用作统计，包括：</p> <ul><li>count([distinct]*)    统计所有的行数（distinct表示去重再统计，下同）</li> <li>count([distinct]列名)    统计某列的值总和</li> <li>sum([distinct]列名)    求一列的和（注意必须是数字类型的）</li> <li>avg([distinct]列名)    求一列的平均值（注意必须是数字类型）</li> <li>max([distinct]列名)    求一列的最大值</li> <li>min([distinct]列名)    求一列的最小值</li></ul> <p>比如我们需要计算某个表一共有多少行：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> student
</code></pre></div><p>通过使用COUNT聚集函数，就可以快速统计并得到结果，比如我们想计算某一列上所有数字的和：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token function">SUM</span><span class="token punctuation">(</span>sid<span class="token punctuation">)</span> <span class="token keyword">FROM</span> student
</code></pre></div><p>通过SUM聚集函数，就可以快速计算每一列的和，实际上这些函数都是由系统提供的函数，我们可以直接使用。</p> <p>本版块我们会详细介绍各类系统函数以及如何编写自定义函数。</p> <h3 id="系统函数"><a href="#系统函数" class="header-anchor">#</a> 系统函数</h3> <p>系统为我们提供的函数也是非常实用的，我们将会分为几个类型进行讲解。</p> <h4 id="字符串函数"><a href="#字符串函数" class="header-anchor">#</a> 字符串函数</h4> <p>处理字符串是一个比较重要的内容，我们可以使用字符串函数来帮助我们快速处理字符串，其中常用比如用于字符串分割的函数有：</p> <ul><li>substring(字符串, 起始位置, 结束位置)     同Java中String类的substring一致，但是注意下标是从1开始，下同</li> <li>left(字符串, 长度)     从最左边向右截取字符串</li> <li>right(字符串, 长度)     从最右边向左截取字符串</li></ul> <p>比如我们只想获取所有学生姓名的第二个字，那么可以像这样写：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> SUBSTRING<span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> student
</code></pre></div><p>比如我们想获取所有学生姓名的第一个字，可以像这样写：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token keyword">LEFT</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> student
</code></pre></div><p>我们还可以利用字符串函数来快速将所有的字母转换为大写字母或是快速转换为小写字母：</p> <ul><li>upper(字符串)     字符串中的所有字母转换为大写字母</li> <li>lower(字符串)     字符串中的所有字母转换为小写字母</li></ul> <p>比如我们希望将一个字符串所有字符专为大写：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> UPPER<span class="token punctuation">(</span><span class="token string">'abcdefg'</span><span class="token punctuation">)</span>
</code></pre></div><p>我们也可以像Java中那样直接对字符串中的内容进行替换：</p> <ul><li>replace(字符串, 原文, 替换文)      同Java中String的replace效果</li></ul> <p>比如现在我们希望将查询到的所有同学的名称中的<code>小</code>全部替换<code>大</code>：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token keyword">REPLACE</span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token string">'小'</span><span class="token punctuation">,</span> <span class="token string">'大'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> student
</code></pre></div><p>字符串也支持进行拼接，系统提供了字符串的拼接函数：</p> <ul><li>concat(字符串1, 字符串2)   连接两个字符串</li></ul> <p>比如我们希望将查询到的所有同学的名称最后都添加一个<code>子</code>字：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> concat<span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">'子'</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> student
</code></pre></div><p>最后就是计算字符串的长度：</p> <ul><li>length(字符串)    获取字符串长度（注意如果使用的是UTF-8编码格式，那么一个汉字占3字节，数字和字母占一个字节）</li></ul> <p>比如我们要获取所有人名字的长度：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> LENGTH<span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> student
</code></pre></div><h4 id="日期函数"><a href="#日期函数" class="header-anchor">#</a> 日期函数</h4> <p>MySQL提供的日期函数也非常实用，我们可以快速对日期进行操作，比如我们想要快速将日期添加N天，就可以使用：</p> <ul><li>date_add(日期, interval 增量 单位)</li></ul> <p>比如我们希望让2022-1-1向后5天：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> DATE_ADD<span class="token punctuation">(</span><span class="token string">'2022-1-1'</span><span class="token punctuation">,</span><span class="token keyword">INTERVAL</span> <span class="token number">5</span> <span class="token keyword">day</span><span class="token punctuation">)</span>
</code></pre></div><p>同理，向前1年：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> DATE_ADD<span class="token punctuation">(</span><span class="token string">'2022-1-1'</span><span class="token punctuation">,</span><span class="token keyword">INTERVAL</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">year</span><span class="token punctuation">)</span>
</code></pre></div><p>单位有：year（年）、month（月）、day（日）、hour（小时）、minute（分钟）、second（秒）</p> <p>我们还可以快速计算日期的间隔天数：</p> <ul><li>datediff(日期1, 日期2)</li></ul> <p>比如我们想计算2022年的2月有多少天：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> DATEDIFF<span class="token punctuation">(</span><span class="token string">'2022-3-1'</span><span class="token punctuation">,</span><span class="token string">'2022-2-1'</span><span class="token punctuation">)</span>
</code></pre></div><p>如果我们想快速获取当前时间的话，可以使用这些：</p> <ul><li>curdate()     当前的日期</li> <li>curtime()     当前的时间</li> <li>now()    当前的日期+时间</li></ul> <p>此函数之前我们在编写实战项目的时候已经使用过了，这里就不演示了。我们也可以单独获取时间中的某个值：</p> <ul><li>day(日期)    获取日期是几号</li> <li>month(日期)   获取日期是几月</li> <li>year(日期)      获取日期是哪一年</li></ul> <p>比如我们想获取今天是几号：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token keyword">DAY</span><span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="数学函数"><a href="#数学函数" class="header-anchor">#</a> 数学函数</h4> <p>数学函数比较常规，基本与Java的Math工具类一致，这里列出即可，各位可以自行尝试：</p> <ul><li>abs(x)   求x的绝对值</li> <li>ceiling(x)   x向上取整</li> <li>floor(x)  x向下取整</li> <li>round(x, 精度)  x取四舍五入，遵循小数点精度</li> <li>exp(x)   e的x次方</li> <li>rand()   0-1之间的随机数</li> <li>log(x)    x的对数</li> <li>pi()     π</li> <li>power(x, n)    x的n次方</li> <li>sqrt(x)     x的平方根</li> <li>sin(x)  cos(x)   tan(x)     三角函数（貌似没有arctan这类反函数？）</li></ul> <h4 id="类型转换函数"><a href="#类型转换函数" class="header-anchor">#</a> 类型转换函数</h4> <p>MySQL的类型转换也分为隐式类型转换和显示类型转换，首先我们来看看隐式类型转换：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token number">1</span><span class="token operator">+</span><span class="token string">'2'</span>
</code></pre></div><p>虽然这句中既包含了数字和字符，但是字符串会被进行隐式转换（注意这里并不是按照字符的ASCII码转换，而是写的多少表示多少）所以最后得到的就是1+2的结果为3</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> CONCAT<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">)</span>
</code></pre></div><p>这里因为需要传入字符串类型的数据，但是我们给的是1这个数字，因此这里也会发生隐式类型转换，1会被直接转换为字符串的'1'，所以这里得到的结果是'12'</p> <p>在某些情况下，我们可能需要使用强制类型转换来将得到的数据转换成我们需要的数据类型，这时就需要用到类型转换函数了，MySQL提供了：</p> <ul><li>cast(数据   as 数据类型)</li></ul> <p>数据类型有以下几种：</p> <ul><li>BINARY[(N)] ：二进制字符串，转换后长度小于N个字节</li> <li>CHAR[(N)] ：字符串，转换后长度小于N个字符</li> <li>DATE ：日期</li> <li>DATETIME ：日期时间</li> <li>DECIMAL[(M[,N])] ：浮点数，M为数字总位数(包括整数部分和小数部分)，N为小数点后的位数</li> <li>SIGNED [INTEGER] ：有符号整数</li> <li>TIME ：时间</li> <li>UNSIGNED [INTEGER] ：无符号整数</li></ul> <p>比如我们现在需要将一个浮点数转换为一个整数：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span>pi<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> SIGNED<span class="token punctuation">)</span>
</code></pre></div><p>我们还可以将字符串转换为数字，会自动进行扫描，值得注意的是一旦遇到非数字的字符，会停止扫描：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> CAST<span class="token punctuation">(</span><span class="token string">'123abc456'</span> <span class="token keyword">as</span> SIGNED<span class="token punctuation">)</span>
</code></pre></div><p>除了cast以外还有convert函数，功能比较相似，这里就不做讲解了。</p> <h4 id="流程控制函数"><a href="#流程控制函数" class="header-anchor">#</a> 流程控制函数</h4> <p>MySQL还为我们提供了很多的逻辑判断函数，比如：</p> <ul><li>if(条件表达式, 结果1, 结果2)    与Java中的三目运算符一致 a &gt; b ? &quot;AAA&quot; : &quot;BBB&quot;</li> <li>ifnull(值1, 值2)     如果值1为NULL则返回值2，否则返回值1</li> <li>nullif(值1, 值2)     如果值1与值2相等，那么返回NULL</li> <li>isnull(值)      判断值是否为NULL</li></ul> <p>比如现在我们想判断：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token keyword">IF</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'lbwnb'</span><span class="token punctuation">,</span><span class="token string">'yyds'</span><span class="token punctuation">)</span>
</code></pre></div><p>通过判断函数，我们就可以很方便地进行一些条件判断操作。</p> <p>除了IF条件判断，我们还可以使用类似Switch一样的语句完成多分支结构：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> 
<span class="token keyword">CASE</span> <span class="token number">2</span>
	<span class="token keyword">WHEN</span> <span class="token number">1</span> <span class="token keyword">THEN</span>
		<span class="token number">10</span>
	<span class="token keyword">ELSE</span>
		<span class="token number">5</span>
<span class="token keyword">END</span><span class="token punctuation">;</span>
</code></pre></div><p>我们也可以将自定义的判断条件放入When之后，它类似于else-if：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> 
<span class="token keyword">CASE</span>
	<span class="token keyword">WHEN</span> <span class="token number">3</span><span class="token operator">&gt;</span><span class="token number">5</span> <span class="token keyword">THEN</span>
		<span class="token number">10</span>
	<span class="token keyword">WHEN</span> <span class="token number">0</span><span class="token operator">&lt;</span><span class="token number">1</span> <span class="token keyword">THEN</span>
		<span class="token number">11</span>
	<span class="token keyword">ELSE</span>
		<span class="token number">5</span>
<span class="token keyword">END</span><span class="token punctuation">;</span>
</code></pre></div><p>还有一个类似于Java中的Thread.sleep的函数，以秒为单位：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> sleep<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>有关MySQL8.0新增的窗口函数这里暂时不做介绍。</p> <h3 id="自定义函数"><a href="#自定义函数" class="header-anchor">#</a> 自定义函数</h3> <p>除了使用系统为我们提供的函数以外，我们也可以自定义函数，并使用我们自定义的函数进行数据处理，唯一比较麻烦的就是函数定义后不能修改，只能删了重新写。</p> <h4 id="基本语法"><a href="#基本语法" class="header-anchor">#</a> 基本语法</h4> <p>MySQL的函数与Java中的方法类似，也可以添加参数和返回值，可以通过<code>CREATE FUNCTION</code>创建函数：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> test<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">RETURNS</span> <span class="token keyword">INT</span>
<span class="token keyword">BEGIN</span>
<span class="token keyword">RETURN</span> <span class="token number">666</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>定义函数的格式为：</p> <ul><li>create function 函数名称([参数列表]) returns 返回值类型</li> <li>begin 和 end 之间写函数的其他逻辑，begin和end就相当于Java中的花括号<code>{ ... }</code></li> <li>return后紧跟返回的结果</li></ul> <p>添加参数也很简单，我们只需要在函数名称括号中添加即可，注意类型需要写在参数名称后面：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">FUNCTION</span> test<span class="token punctuation">(</span>i <span class="token keyword">INT</span><span class="token punctuation">)</span> <span class="token keyword">RETURNS</span> <span class="token keyword">INT</span>
<span class="token keyword">BEGIN</span>
<span class="token keyword">RETURN</span> i <span class="token operator">*</span> i<span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>我们可以在BEGIN和RETURN之间编写一些其他的逻辑，比如我们想要定义一个局部变量，并为其赋值：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span><span class="token punctuation">;</span>
<span class="token keyword">SET</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">RETURN</span> i <span class="token operator">*</span> i <span class="token operator">*</span> a<span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>定义局部变量的格式为：</p> <ul><li>declare 变量名称 变量类型 [, ...]</li> <li>declare 变量名称 变量类型 default 默认值</li></ul> <p>为变量赋值的格式为：</p> <ul><li>set 变量名称 = 值</li></ul> <p>我们还可以在函数内部使用<code>select</code>语句，它可以直接从表中读取数据，并可以结合into关键字将查询结果赋值给变量：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span><span class="token punctuation">;</span>
<span class="token comment">-- select into from 语句</span>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">INTO</span> a <span class="token keyword">FROM</span> student<span class="token punctuation">;</span>
<span class="token keyword">RETURN</span> a<span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><h4 id="流程控制"><a href="#流程控制" class="header-anchor">#</a> 流程控制</h4> <p>接着我们来看一下如何使用流程控制语句，其中最关键的就是IF判断语句：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">IF</span> a <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token keyword">THEN</span>
	<span class="token keyword">RETURN</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">ELSE</span>
	<span class="token keyword">RETURN</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>IF分支语句的格式为：</p> <ul><li>if 判断条件 then  ... else if 判断条件 then .... else ... end if;</li></ul> <p>我们可以结合<code>exists</code>关键字来判断是否为NULL：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">-- IF EXISTS(SELECT * FROM student WHERE sid = 100) THEN</span>
<span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> sid <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">THEN</span>
	<span class="token keyword">SET</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>
<span class="token keyword">RETURN</span> a<span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>我们也可以在函数中使用switch语句：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">CASE</span> a
	<span class="token keyword">WHEN</span> <span class="token number">10</span> <span class="token keyword">THEN</span>
		<span class="token keyword">RETURN</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">ELSE</span>
		<span class="token keyword">RETURN</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> <span class="token keyword">CASE</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>SWITCH分支语句的格式为：</p> <ul><li>case 变量 when 具体值或是布尔表达式 then ... when * then ... else ... end case;</li></ul> <p>与Java不同的是，它支持使用布尔表达式：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">CASE</span>
	<span class="token keyword">WHEN</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token keyword">THEN</span>
		<span class="token keyword">SET</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
	<span class="token keyword">ELSE</span>
		<span class="token keyword">SET</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> <span class="token keyword">CASE</span><span class="token punctuation">;</span>
<span class="token keyword">RETURN</span> a<span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>我们以类似于elseif的形式进行判断，其实和上面直接使用是一样的。</p> <p>我们接着来看循环语句，MySQL提供了三种循环语句，其中第一种是WHILE语句：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">WHILE</span> a <span class="token operator">&lt;</span> <span class="token number">11</span> <span class="token keyword">DO</span>
	<span class="token keyword">SET</span> a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span>
<span class="token keyword">RETURN</span> a<span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>格式为：</p> <ul><li>while 循环条件 do ...  end while;</li></ul> <p>我们接着来看第二种循环语句，LOOP循环：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">10</span><span class="token punctuation">;</span>
lp1: <span class="token keyword">LOOP</span>
  <span class="token keyword">SET</span> a <span class="token operator">=</span> a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">IF</span> a <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">THEN</span>
		<span class="token keyword">LEAVE</span> lp1<span class="token punctuation">;</span> 
	<span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span> 
<span class="token keyword">END</span> <span class="token keyword">LOOP</span> lp1<span class="token punctuation">;</span>
<span class="token keyword">RETURN</span> a<span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>相比while语句，我们可以使用<code>LEAVE</code>精准控制结束哪个循环，有点类似于goto语句：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span>
lp1: <span class="token keyword">LOOP</span>
  lp2: <span class="token keyword">LOOP</span>
	<span class="token keyword">SET</span> a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">IF</span> a <span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token keyword">THEN</span>
		<span class="token keyword">LEAVE</span> lp1<span class="token punctuation">;</span> 
	<span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span> 
	<span class="token keyword">END</span> <span class="token keyword">LOOP</span> lp2<span class="token punctuation">;</span>
<span class="token keyword">END</span> <span class="token keyword">LOOP</span> lp1<span class="token punctuation">;</span>
<span class="token keyword">RETURN</span> a<span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>类似于Java中的goto写法（在JavaSE阶段已经讲解过）：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    lp1<span class="token operator">:</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        lp2<span class="token operator">:</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            a<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">break</span> lp1<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它的语法格式如下：</p> <ul><li>循环名称 loop ...(可以插入leave语句结束) end loop 循环名称;</li></ul> <p>接着我们来看最后一种循环语句，repeat语句：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">REPEAT</span>
	<span class="token keyword">SET</span> a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
UNTIL a <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">END</span> <span class="token keyword">REPEAT</span><span class="token punctuation">;</span>
<span class="token keyword">RETURN</span> a<span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>它类似于Java中的do-while循环语句，它会先去执行里面的内容，再进行判断，格式为：</p> <ul><li>repeat ... until 结束循环条件 end repeat;</li></ul> <h4 id="全局变量"><a href="#全局变量" class="header-anchor">#</a> 全局变量</h4> <p>某些情况下，我们可以直接在一次会话中直接定义变量并使用，这时它并不是位于函数内的，这就是全局变量，它无需预先定义，直接使用即可：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">set</span> <span class="token variable">@x</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>我们可以将全局变量作为参数传递给函数：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> test<span class="token punctuation">(</span><span class="token variable">@x</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>除了我们自己定义的全部变量以外，系统默认也有很多的变量，因此我们自己定义的变量称为用户变量，系统默认变量称为系统变量。查看系统变量的命令为：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token keyword">GLOBAL</span> VARIABLES
</code></pre></div><hr> <h2 id="存储过程"><a href="#存储过程" class="header-anchor">#</a> 存储过程</h2> <p>存储过程是一个包括多条SQL语句的集合，专用于特定表的特定操作，比如我们之前实战项目中的创建用户，那么我们就需要一次性为两张表添加数据，但是如果不使用Java，而是每次都去使用SQL命令来完成，就需要手动敲两次命令，非常麻烦，因此我们可以提前将这些操作定义好，预留出需要填写数据的位置，下次输入参数直接调用即可。</p> <p>这里很容易与函数搞混淆，存储过程也是执行多条SQL语句，但是它们的出发点不一样，函数是专用于进行数据处理，并将结果返回给调用者，它更多情况下是一条SQL语句的参与者，无法直接运行，并且不涉及某个特定表：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> student<span class="token punctuation">;</span>
</code></pre></div><p>而存储过程是多条SQL语句的执行者，这是它们的本质区别。</p> <p>定义存储过程与定义函数极为相似，它也可以包含参数，函数中使用的语句这里也能使用，但是它没有返回值：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> lbwnb<span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pwd <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
  <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> users<span class="token punctuation">(</span>username<span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>password<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>我们可以在存储过程中编写多条SQL语句，但是注意，MySQL的存储过程不具有原子性，当出现错误时，并不会回滚之前的操作，因此需要我们自己来编写事务保证原子性。</p> <p>接着我们来看看如何执行存储过程：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CALL</span> lbwnb<span class="token punctuation">(</span><span class="token string">'111'</span><span class="token punctuation">,</span> <span class="token string">'2222'</span><span class="token punctuation">)</span>
</code></pre></div><p>通过使用<code>call</code>来执行一个存储过程，如果存储过程有参数，那么还需要填写参数。</p> <p>比如现在我们想要实现查询用户表，如果包含用户<code>test</code>那么就删除用户，如果不包含，就添加用户：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> <span class="token identifier"><span class="token punctuation">`</span>lbwnb<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'test'</span><span class="token punctuation">)</span> <span class="token keyword">THEN</span>
		<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> users<span class="token punctuation">(</span>username<span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>password<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">,</span> <span class="token string">'123456'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">ELSE</span>
		<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> users <span class="token keyword">WHERE</span> username <span class="token operator">=</span> <span class="token string">'test'</span><span class="token punctuation">;</span>
	<span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>这里其实只需要一个简单的IF判断即可实现。</p> <p>那么如果我们希望遍历一个SELECT语句查询的结果呢？我们可以使用游标来完成：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
	<span class="token keyword">DECLARE</span> id <span class="token keyword">INT</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> sex <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> cur <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student<span class="token punctuation">;</span>
	<span class="token keyword">OPEN</span> cur<span class="token punctuation">;</span>
	<span class="token keyword">WHILE</span> <span class="token boolean">TRUE</span> <span class="token keyword">DO</span>
		<span class="token keyword">FETCH</span> cur <span class="token keyword">INTO</span> id<span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> sex<span class="token punctuation">;</span>
		<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> sex<span class="token punctuation">;</span>
	<span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span>
	<span class="token keyword">CLOSE</span> cur<span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>游标的使用分为4个步骤：</p> <ul><li>DECLARE 游标名称 CURSOR FOR 查询结果   -  定义游标</li> <li>OPEN cur     -   开启游标</li> <li>FETCH 游标名称 INTO 存储结果的变量    -    从顶部开始，每执行一次，向下移动，如果已经在最底部，则触发异常</li> <li>CLOSE cur    -   关闭游标</li></ul> <p>我们这里利用了一个while循环来多次通过游标获取查询结果，但是最后是因为出现异常才退出的，这样会导致之后的代码就无法继续正常运行了。</p> <p>我们接着来看如何处理异常：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">BEGIN</span>
	<span class="token keyword">DECLARE</span> id <span class="token keyword">INT</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> sex <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> score <span class="token keyword">INT</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> a <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">DECLARE</span> cur <span class="token keyword">CURSOR</span> <span class="token keyword">FOR</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student<span class="token punctuation">;</span>
	<span class="token comment">-- 必须在游标定义之后编写</span>
	<span class="token keyword">DECLARE</span> <span class="token keyword">CONTINUE</span> <span class="token keyword">HANDLER</span> <span class="token keyword">FOR</span> <span class="token number">1329</span> <span class="token keyword">SET</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">OPEN</span> cur<span class="token punctuation">;</span>
	<span class="token keyword">WHILE</span> a <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">DO</span>
		<span class="token keyword">FETCH</span> cur <span class="token keyword">INTO</span> id<span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> sex<span class="token punctuation">,</span> score<span class="token punctuation">;</span>
		<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span><span class="token punctuation">,</span> sex<span class="token punctuation">,</span> score<span class="token punctuation">;</span>
	<span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span>
	<span class="token keyword">CLOSE</span> cur<span class="token punctuation">;</span>
	<span class="token keyword">SELECT</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>我们可以声明一个异常处理器（句柄），格式如下：</p> <ul><li>declear (continue/exit) handler for 异常名称(ID) 做点什么</li></ul> <p>我们还可以限定存储过程的参数传递，比如我们只希望用户给我们一个参数用于接收数据，而不是值传递，我们可以将其设定为OUT类型：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> <span class="token identifier"><span class="token punctuation">`</span>lbwnb<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token keyword">OUT</span> a <span class="token keyword">INT</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
	<span class="token keyword">SELECT</span> a<span class="token punctuation">;</span>
	<span class="token keyword">SET</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">END</span>
</code></pre></div><p>所有的参数默认为<code>IN</code>类型，也就是只能作为传入参数，无法为其赋值，而这里讲参数设定为<code>OUT</code>类型，那么参数无法将值传入，而只能被赋值。</p> <p>如果我们既希望参数可以传入也可以被重新赋值，我们可以将其修改为<code>INOUT</code>类型。</p> <hr> <h2 id="存储引擎"><a href="#存储引擎" class="header-anchor">#</a> 存储引擎</h2> <p>存储引擎就像我们电脑中的CPU，它是整个MySQL最核心的部分，数据库中的数据如何存储，数据库能够支持哪些功能，我们的增删改查请求如何执行，都是由存储引擎来决定的。</p> <p>我们可以大致了解一下以下三种存储引擎：</p> <ul><li>**MyISAM：**MySQL5.5之前的默认存储引擎，在插入和查询的情况下性能很高，但是它不支持事务，只能添加表级锁。</li> <li>**InnoDB：**MySQL5.5之后的默认存储引擎，它支持ACID事务、行级锁、外键，但是性能比不过MyISAM，更加消耗资源。</li> <li>**Memory：**数据都存放在内存中，数据库重启或发生崩溃，表中的数据都将消失。</li></ul> <p>我们可以使用下面的命令来查看MySQL支持的存储引擎：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">show</span> engines<span class="token punctuation">;</span>
</code></pre></div><p>在创建表时，我们也可以为表指定其存储引擎。</p> <p>我们还可以在配置文件中修改默认的存储引擎，在Windows 11系统下，MySQL的配置文件默认放在<code>C:\ProgramData\MySQL\MySQL Server 5.7</code>中，注意ProgramData是个隐藏文件夹。</p> <hr> <h2 id="索引-2"><a href="#索引-2" class="header-anchor">#</a> 索引</h2> <p>**注意：**本小节会涉及<code>数据结构与算法</code>相关知识。</p> <p>索引就好像我们书的目录，每本书都有一个目录用于我们快速定位我们想要的内容在哪一页，索引也是，通过建立索引，我们就可以根据索引来快速找到想要的一条记录，大大提高查询效率。</p> <p>本版块我们会详细介绍索引的几种类型，以及索引的底层存储原理。</p> <h3 id="单列索引"><a href="#单列索引" class="header-anchor">#</a> 单列索引</h3> <p>单列索引只针对于某一列数据创建索引，单列索引有以下几种类型：</p> <ul><li><strong>NORMAL</strong>：普通的索引类型，完完全全相当于一本书的目录。</li> <li><strong>UNIQUE</strong>：唯一索引，我们之前已经用过了，一旦建立唯一索引，那么整个列中将不允许出现重复数据。每个表的主键列，都有一个特殊的唯一索引，叫做Primary Key，它不仅仅要求不允许出现重复，还要求不能为NULL，它还可以自动递增。每张表可以有多个唯一索引，但是只能有一个Primary索引。</li> <li><strong>SPATIAL</strong>：空间索引，空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON，不是很常用，这里不做介绍。</li> <li><strong>FULLTEXT</strong>：全文索引（MySQL 5.6 之后InnoDB才支持），它是模糊匹配的一种更好的解决方案，它的效率要比使用<code>like %</code>更高，并且它还支持多种匹配方式，灵活性也更加强大。只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。</li></ul> <p>我们来看看如何使用全文索引，首先创建一张用于测试全文索引的表：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> articles <span class="token punctuation">(</span>
  id <span class="token keyword">INT</span> <span class="token keyword">UNSIGNED</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
  title <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  body <span class="token keyword">TEXT</span><span class="token punctuation">,</span>
  FULLTEXT <span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> articles <span class="token keyword">VALUES</span>
	<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'MySQL Tutorial'</span><span class="token punctuation">,</span> <span class="token string">'DBMS stands for DataBase ...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'How To Use MySQL Efficiently'</span><span class="token punctuation">,</span> <span class="token string">'After you went through a ...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'Optimising MySQL'</span><span class="token punctuation">,</span><span class="token string">'In this tutorial we will show ...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'1001 MySQL Tricks'</span><span class="token punctuation">,</span><span class="token string">'1. Never run mysqld as root. 2. ...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'MySQL vs. YourSQL'</span><span class="token punctuation">,</span> <span class="token string">'In the following database comparison ...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span><span class="token boolean">NULL</span><span class="token punctuation">,</span><span class="token string">'MySQL Security'</span><span class="token punctuation">,</span> <span class="token string">'When configured properly, MySQL ...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>最后我们使用全文索引进行模糊匹配：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> articles <span class="token keyword">WHERE</span> <span class="token keyword">MATCH</span> <span class="token punctuation">(</span>body<span class="token punctuation">)</span> AGAINST <span class="token punctuation">(</span><span class="token string">'database'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意全文索引如何定义字段的，match中就必须是哪些字段，against中定义需要模糊匹配的字符串，我们用作查找的字符串实际上是被分词之后的结果，如果进行模糊匹配的不是一个词语，那么会查找失败，但是它的效率远高于以下这种写法：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> articles <span class="token keyword">WHERE</span> body <span class="token operator">like</span> <span class="token string">'%database%'</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="组合索引"><a href="#组合索引" class="header-anchor">#</a> 组合索引</h3> <p>组合索引实际上就是将多行捆绑在一起，作为一个索引，它同样支持以上几种索引类型，我们可以在Navicat中进行演示。</p> <p>注意组合索引在进行匹配时，遵循最左原则。</p> <p>我们可以使用<code>explain</code>语句（它可以用于分析select语句的执行计划，也就是MySQL到底是如何在执行某条select语句的）来分析查询语句到底有没有通过索引进行匹配。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'小王'</span><span class="token punctuation">;</span>
</code></pre></div><p>得到的结果如下：</p> <ul><li>select_type：查询类型，上面的就是简单查询（SIMPLE）</li> <li>table：查询的表</li> <li>type：MySQL决定如何查找对应的记录，效率从高到低：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</li> <li>possible_keys：执行查询时可能会用到的索引</li> <li>key：实际使用的索引</li> <li>key_len：Mysql在索引里使用的字节数，字段的最大可能长度</li> <li>rows：扫描的行数</li> <li>extra：附加说明</li></ul> <h3 id="索引底层原理"><a href="#索引底层原理" class="header-anchor">#</a> 索引底层原理</h3> <p>在了解完了索引的类型之后，我们接着来看看索引是如何实现的。</p> <p>既然我们要通过索引来快速查找内容，那么如何设计索引就是我们的重点内容，因为索引是存储在硬盘上的，跟我们之前使用的HashMap之类的不同，它们都是在内存中的，但是硬盘的读取速度远小于内存的速度，每一次IO操作都会耗费大量的时间，我们也不可能把整个磁盘上的索引全部导入内存，因此我们需要考虑尽可能多的减少IO次数，索引的实现可以依靠两种数据结构，一种是我们在JavaSE阶段已经学习过的Hash表，还有一种就是B-Tree。</p> <p>我们首先来看看哈希表，实际上就是计算Hash值来快速定位：</p> <p><img src="http://notepicture.fvcsavstudy.cn/BackEnd/Database/mysql-4.jpg" alt="点击查看源网页"></p> <p>通过对Key进行散列值计算，我们可以直接得到对应数据的存放位置，它的查询效率能够达到O(1)，但是它也存在一定的缺陷：</p> <ul><li>Hash索引仅仅能满足“=”，“in”查询条件，不能使用范围查询。</li> <li>Hash碰撞问题。</li> <li>不能用部分索引键来搜索，因为组合索引在计算哈希值的时候是一起计算的。</li></ul> <p>那么，既然要解决这些问题，我们还有一种方案就是使用类似于二叉树那样的数据结构来存储索引，但是这样相比使用Hash索引，会牺牲一定的读取速度。</p> <p>但是这里并没有使用二叉树，而是使用了BTree，它是专门为磁盘数据读取设计的一种度为n的查找树：</p> <ul><li><p>树中每个结点最多含有m个孩子（m &gt;= 2）</p></li> <li><p>除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子。</p></li> <li><p>若根结点不是叶子结点，则至少有2个孩子。</p></li> <li><p>所有叶子结点都出现在同一层。</p></li> <li><p>每个非终端结点中包含有n个键值信息： (P1，K1，P2，K2，P3，......，Kn，Pn+1)。其中：</p> <ol><li>Ki (i=1...n)为键值，且键值按顺序升序排序K(i-1)&lt; Ki。</li> <li>Pi为指向子树根的结点，且指针P(i)指向的子树中所有结点的键值均小于Ki，但都大于K(i-1)。</li> <li>键值的个数n必须满足： [ceil(m / 2)-1] &lt;= n &lt;= m-1。</li></ol></li></ul> <p><img src="http://notepicture.fvcsavstudy.cn/BackEnd/Database/mysql-5.png" alt="img"></p> <p>比如现在我们要对键值为<strong>10</strong>的记录进行查找，过程如下：</p> <ol><li>读取根节点数据（目前进行了一次IO操作）</li> <li>根据根节点数据进行判断得到10&lt;17，因为P1指向的子树中所有值都是小于17的，所以这时我们将P1指向的节点读取（目前进行了两次IO操作）</li> <li>再次进行判断，得到8&lt;10&lt;12，因为P2指向的子树中所有的值都是小于12大于8的，所以这时读取P2指向的节点（目前进行了三次IO操作）</li> <li>成功找到。</li></ol> <p>我们接着来看，虽然BTree能够很好地利用二叉查找树的思想大幅度减少查找次数，但是它的查找效率还是很低，因此它的优化版本B+Tree诞生了，它拥有更稳定的查询效率和更低的IO读取次数：</p> <p><img src="http://notepicture.fvcsavstudy.cn/BackEnd/Database/mysql-6.png" alt="img"></p> <p>我们可以发现，它和BTree有一定的区别：</p> <ul><li>有n棵子树的结点中含有n个键值，BTree只有n-1个。</li> <li>所有的键值信息只在叶子节点中包含，非叶子节点仅仅保存子节点的最小（或最大）值，和指向叶子节点的指针，这样相比BTree每一个节点在硬盘中存放了更少的内容（没有键值信息了）</li> <li>所有叶子节点都有一个根据大小顺序指向下一个叶子节点的指针Q，本质上数据就是一个链表。</li></ul> <p>这样，读取IO的时间相比BTree就减少了很多，并且查询任何键值信息都需要完整地走到叶子节点，保证了查询的IO读取次数一致。因此MySQL默认选择B+Tree作为索引的存储数据结构。</p> <p>这是MyISAM存储引擎下的B+Tree实现：</p> <p><img src="http://notepicture.fvcsavstudy.cn/BackEnd/Database/mysql-7.png" alt="img"></p> <p>这是InnoDB存储引擎下的B+Tree实现：</p> <p><img src="http://notepicture.fvcsavstudy.cn/BackEnd/Database/mysql-8.png" alt="img"></p> <p><img src="http://notepicture.fvcsavstudy.cn/BackEnd/Database/mysql-9.png" alt="img"></p> <p>InnoDB与MyISAM实现的不同之处：</p> <ul><li>数据本身就是索引的一部分（所以这里建议主键使用自增）</li> <li>非主键索引的数据实际上存储的是对应记录的主键值（因此InnoDB必须有主键，若没有也会自动查找替代）</li></ul> <hr> <h2 id="锁机制"><a href="#锁机制" class="header-anchor">#</a> 锁机制</h2> <p>在JavaSE的学习中，我们在多线程板块首次用到了锁机制，当我们对某个方法或是某个代码块加锁后，除非锁的持有者释放当前的锁，否则其他线程无法进入此方法或是代码块，我们可以利用锁机制来保证多线程之间的安全性。</p> <p>在MySQL中，就很容易出现多线程同时操作表中数据的情况，如果要避免潜在的并发问题，那么我们可以使用之前讲解的事务隔离级别来处理，而事务隔离中利用了锁机制。</p> <ul><li>读未提交(Read Uncommitted)：能够读取到其他事务中未提交的内容，存在脏读问题。</li> <li>读已提交(Read Committed RC)：只能读取其他事务已经提交的内容，存在不可重复读问题。</li> <li>可重复读(Repeated Read RR)：在读取某行后不允许其他事务操作此行，直到事务结束，但是依然存在幻读问题。</li> <li>串行读(Serializable)：一个事务的开始必须等待另一个事务的完成。</li></ul> <p>我们可以切换隔离级别分别演示一下：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">uncommitted</span><span class="token punctuation">;</span>
</code></pre></div><p>在RR级别下，MySQL在一定程度上解决了幻读问题：</p> <ul><li>在快照读（不加锁）读情况下，mysql通过mvcc来避免幻读。</li> <li>在当前读（加锁）读情况下，mysql通过next-key来避免幻读。</li></ul> <blockquote><p><strong><code>MVCC</code></strong>，全称 <code>Multi-Version Concurrency Control</code> ，即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p></blockquote> <h3 id="读锁和写锁"><a href="#读锁和写锁" class="header-anchor">#</a> 读锁和写锁</h3> <p>从对数据的操作类型上来说，锁分为读锁和写锁：</p> <ul><li>**读锁：**也叫共享锁，当一个事务添加了读锁后，其他的事务也可以添加读锁或是读取数据，但是不能进行写操作，只能等到所有的读锁全部释放。</li> <li>**写锁：**也叫排他锁，当一个事务添加了写锁后，其他事务不能读不能写也不能添加任何锁，只能等待当前事务释放锁。</li></ul> <h3 id="全局锁、表锁和行锁"><a href="#全局锁、表锁和行锁" class="header-anchor">#</a> 全局锁、表锁和行锁</h3> <p>从锁的作用范围上划分，分为全局锁、表锁和行锁：</p> <ul><li>**全局锁：**锁作用于全局，整个数据库的所有操作全部受到锁限制。</li> <li>**表锁：**锁作用于整个表，所有对表的操作都会收到锁限制。</li> <li>**行锁：**锁作用于表中的某一行，只会通过锁限制对某一行的操作（仅InnoDB支持）</li></ul> <h4 id="全局锁"><a href="#全局锁" class="header-anchor">#</a> 全局锁</h4> <p>我们首先来看全局锁，它作用于整个数据库，我们可以使用以下命令来开启读全局锁：</p> <div class="language-sql extra-class"><pre class="language-sql"><code>flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span><span class="token punctuation">;</span>
</code></pre></div><p>开启后，整个数据库被上读锁，我们只能去读取数据，但是不允许进行写操作（包括更新、插入、删除等）一旦执行写操作，会被阻塞，直到锁被释放，我们可以使用以下命令来解锁：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">unlock</span> <span class="token keyword">tables</span><span class="token punctuation">;</span>
</code></pre></div><p>除了手动释放锁之外，当我们的会话结束后，锁也会被自动释放。</p> <h4 id="表锁"><a href="#表锁" class="header-anchor">#</a> 表锁</h4> <p>表锁作用于某一张表，也是MyISAM和InnoDB存储引擎支持的方式，我们可以使用以下命令来为表添加锁：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">lock</span> <span class="token keyword">table</span> 表名称 <span class="token keyword">read</span><span class="token operator">/</span><span class="token keyword">write</span><span class="token punctuation">;</span>
</code></pre></div><p>在我们为表添加写锁后，我们发现其他地方是无法访问此表的，一律都被阻塞。</p> <h4 id="行锁"><a href="#行锁" class="header-anchor">#</a> 行锁</h4> <p>表锁的作用范围太广了，如果我们仅仅只是对某一行进行操作，那么大可不必对整个表进行加锁，因此<code>InnoDB</code>支持了行锁，我们可以使用以下命令来对某一行进行加锁：</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 添加读锁（共享锁）</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
<span class="token comment">-- 添加写锁（排他锁）</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre></div><p>使用InnoDB的情况下，在执行更新、删除、插入操作时，数据库也会自动为所涉及的行添加写锁（排他锁），直到事务提交时，才会释放锁，执行普通的查询操作时，不会添加任何锁。使用MyISAM的情况下，在执行更新、删除、插入操作时，数据库会对涉及的表添加写锁，在执行查询操作时，数据库会对涉及的表添加读锁。</p> <p>**提问：**当我们不使用id进行选择，行锁会发生什么变化？（行锁升级）</p> <h3 id="记录锁、间隙锁和临键锁"><a href="#记录锁、间隙锁和临键锁" class="header-anchor">#</a> 记录锁、间隙锁和临键锁</h3> <p>我们知道InnoDB支持使用行锁，但是行锁比较复杂，它可以继续分为多个类型。</p> <h4 id="记录锁"><a href="#记录锁" class="header-anchor">#</a> 记录锁</h4> <p>（Record Locks）记录锁, 仅仅锁住索引记录的一行，在单条索引记录上加锁。Record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚合索引后面加写锁，这个类似于表锁，但原理上和表锁应该是完全不同的。</p> <h4 id="间隙锁"><a href="#间隙锁" class="header-anchor">#</a> 间隙锁</h4> <p>（Gap Locks）仅仅锁住一个索引区间（开区间，不包括双端端点）。在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。比如在 1、2中，间隙锁的可能值有 (-∞, 1)，(1, 2)，(2, +∞)，间隙锁可用于防止幻读，保证索引间的不会被插入数据。</p> <h4 id="临键锁"><a href="#临键锁" class="header-anchor">#</a> 临键锁</h4> <p>（Next-Key Locks）Record lock + Gap lock，左开右闭区间。默认情况下，<code>InnoDB</code>正是使用Next-key Locks来锁定记录（如select … for update语句）它还会根据场景进行灵活变换：</p> <table><thead><tr><th style="text-align:left;">场景</th> <th>转换</th></tr></thead> <tbody><tr><td style="text-align:left;">使用唯一索引进行精确匹配，但表中不存在记录</td> <td>自动转换为 Gap Locks</td></tr> <tr><td style="text-align:left;">使用唯一索引进行精确匹配，且表中存在记录</td> <td>自动转换为 Record Locks</td></tr> <tr><td style="text-align:left;">使用非唯一索引进行精确匹配</td> <td>不转换</td></tr> <tr><td style="text-align:left;">使用唯一索引进行范围匹配</td> <td>不转换，但是只锁上界，不锁下界</td></tr></tbody></table> <p>https://zhuanlan.zhihu.com/p/48269420</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e5928079.js" defer></script><script src="/assets/js/2.733019b2.js" defer></script><script src="/assets/js/9.8d3bb58f.js" defer></script>
  </body>
</html>
